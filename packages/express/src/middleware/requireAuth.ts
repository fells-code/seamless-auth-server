import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";

import { refreshAccessToken } from "../internal/refreshAccessToken.js";
import { setSessionCookie } from "../internal/cookie.js";

/**
 * Express middleware that enforces authentication using Seamless Auth cookies.
 *
 * This guard verifies the signed access cookie generated by the Seamless Auth
 * server. If the access cookie is valid and unexpired, the decoded session
 * payload is attached to `req.user` and the request proceeds.
 *
 * If the access cookie is expired or missing *but* a valid refresh cookie is
 * present, the middleware automatically attempts a silent token refresh using
 * the Seamless Auth server. When successful, new session cookies are issued and
 * the request continues with an updated `req.user`.
 *
 * If neither the access token nor refresh token can validate the session,
 * the middleware returns a 401 Unauthorized error and prevents further
 * route execution.
 *
 * ### Responsibilities
 * - Validates the Seamless Auth session access cookie
 * - Attempts refresh-token–based session renewal when necessary
 * - Populates `req.user` with the verified session payload
 * - Handles all cookie rewriting during refresh flows
 * - Acts as a request-level authentication guard for API routes
 *
 * ### Cookie Parameters
 * - **cookieName** — Name of the access cookie that holds the signed session JWT
 * - **refreshCookieName** — Name of the refresh cookie used for silent token refresh
 * - **cookieDomain** — Domain or path value applied to issued cookies
 *
 * ### Example
 * ```ts
 * // Protect a route
 * app.get("/api/me", requireAuth(), (req, res) => {
 *   res.json({ user: req.user });
 * });
 *
 * // Custom cookie names (if your Seamless Auth server uses overrides)
 * app.use(
 *   "/internal",
 *   requireAuth("sa_access", "sa_refresh", "mycompany.com"),
 *   internalRouter
 * );
 * ```
 *
 * @param cookieName - The access cookie name. Defaults to `"seamless-access"`.
 * @param refreshCookieName - The refresh cookie name used for session rotation. Defaults to `"seamless-refresh"`.
 * @param cookieDomain - Domain or path used when rewriting cookies. Defaults to `"/"`.
 *
 * @returns An Express middleware function that enforces Seamless Auth
 *          authentication on incoming requests.
 */
export function requireAuth(
  cookieName = "seamless-access",
  refreshCookieName = "seamless-refresh",
  cookieDomain = "/"
) {
  const COOKIE_SECRET = process.env.SEAMLESS_COOKIE_SIGNING_KEY!;
  if (!COOKIE_SECRET) {
    console.warn(
      "[SeamlessAuth] SEAMLESS_COOKIE_SIGNING_KEY missing — requireAuth will always fail."
    );
    throw new Error("Missing required env SEAMLESS_COOKIE_SIGNING_KEY");
  }

  const AUTH_SERVER_URL = process.env.AUTH_SERVER_URL!;

  return async (
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      if (!COOKIE_SECRET) {
        throw new Error("Missing required SEAMLESS_COOKIE_SIGNING_KEY env");
      }

      const token = req.cookies?.[cookieName];
      if (!token) {
        res.status(401).json({ error: "Missing access cookie" });
        return;
      }

      try {
        const payload = jwt.verify(token, COOKIE_SECRET, {
          algorithms: ["HS256"],
        });
        (req as any).user = payload;
        return next();
      } catch (err: any) {
        // expired or invalid token
        if (err.name !== "TokenExpiredError") {
          console.warn("[SeamlessAuth] Invalid token:", err.message);
          res.status(401).json({ error: "Invalid token" });
          return;
        }

        // Try refresh
        const refreshToken = req.cookies?.[refreshCookieName];
        if (!refreshToken) {
          res.status(401).json({ error: "Session expired; re-login required" });
          return;
        }

        console.log("[SeamlessAuth] Access token expired — attempting refresh");
        const refreshed = await refreshAccessToken(
          req,
          AUTH_SERVER_URL,
          refreshToken
        );

        if (!refreshed?.token) {
          res.status(401).json({ error: "Refresh failed" });
          return;
        }

        // Update cookie with new access token
        setSessionCookie(
          res,
          {
            sub: refreshed.sub,
            token: refreshed.token,
            roles: refreshed.roles,
          },
          cookieDomain,
          refreshed.ttl,
          cookieName
        );

        setSessionCookie(
          res,
          { sub: refreshed.sub, refreshToken: refreshed.refreshToken },
          req.hostname,
          refreshed.refreshTtl,
          refreshCookieName
        );

        // Decode new token so downstream has user
        const payload = jwt.verify(refreshed.token, COOKIE_SECRET, {
          algorithms: ["HS256"],
        });
        (req as any).user = payload;
        next();
      }
    } catch (err: any) {
      console.error("[SeamlessAuth] requireAuth error:", err.message);
      res.status(401).json({ error: "Invalid or expired access cookie" });
      return;
    }
  };
}
